## 소스코드 분석

HTTP 웹 서버의 핵심이 되는 코드는 webserver 패키지의 **WebServer**와 **RequestHandler** 클래스이다. 

- `WebServer` 클래스 : **웹 서버를 시작**하고, 사용자의 요청이 있을 경우 **사용자의 요청을 RequestHandler 클래스에 위임**하는 역할을 한다.

```java
public class WebServer {
    private static final Logger log = LoggerFactory.getLogger(WebServer.class);
    private static final int DEFAULT_PORT = 8800;

    // 서버를 시작하는 메인 메소드
    public static void main(String args[]) throws Exception {
        int port = 0;
        if (args == null || args.length == 0) {
            port = DEFAULT_PORT;
        } else {
            port = Integer.parseInt(args[0]);
        }

        // 서버소켓을 생성한다. 웹서버는 기본적으로 8080번 포트를 사용한다.
        // ServerSocket :  사용자 요청이 발생할 떄까지 대기 상태에 있도록 지원하는 역할을 담당
        try (ServerSocket listenSocket = new ServerSocket(port)) {
            log.info("Web Application Server started {} port.", port);

            // 클라이언트가 연결될때까지 대기한다.
            Socket connection;
            while ((connection = listenSocket.accept()) != null) {
                // ServerSokect에 사용자 요청이 발생하는 순간
                // 클라이언트와 연결을 담당하는 Socket을
                // RequestHandler에 전달하면서
                // 새로운 스레드를 실행하는 방식으로
                // 멀티 스레드 프로그래밍을 지원
                // (RequestHandler 클래스는 Thread를 상속받음)
                RequestHandler requestHandler = new RequestHandler(connection);
                requestHandler.start(); //Thread의 start 메소드 실행
            }
        }
    }
}

```

- `RequestHandler` 클래스 : Thread를 상속하고 있으며, **사용자의 요청에 대한 처리**와 **응답에 대한 처리**를 담당하는 가장 중심이 되는 클래스

  ```java
  public class RequestHandler extends Thread {
      private static final Logger log = LoggerFactory.getLogger(RequestHandler.class);
  
      private Socket connection;
  
      public RequestHandler(Socket connectionSocket) {
          this.connection = connectionSocket;
      }
  
      public void run() {
          log.debug("New Client Connect! Connected IP : {}, Port : {}", connection.getInetAddress(),
                  connection.getPort());
  
          try (InputStream in = connection.getInputStream(); OutputStream out = connection.getOutputStream()) {
              // TODO 사용자 요청에 대한 처리는 이 곳에 구현하면 된다.
              DataOutputStream dos = new DataOutputStream(out);
              byte[] body = "Hello World".getBytes();
              response200Header(dos, body.length);
              responseBody(dos, body);
          } catch (IOException e) {
              log.error(e.getMessage());
          }
      }
  
      private void response200Header(DataOutputStream dos, int lengthOfBodyContent) {
          try {
              dos.writeBytes("HTTP/1.1 200 OK \r\n");
              dos.writeBytes("Content-Type: text/html;charset=utf-8\r\n");
              dos.writeBytes("Content-Length: " + lengthOfBodyContent + "\r\n");
              dos.writeBytes("\r\n");
          } catch (IOException e) {
              log.error(e.getMessage());
          }
      }
  
      private void responseBody(DataOutputStream dos, byte[] body) {
          try {
              dos.write(body, 0, body.length);
              dos.flush();
          } catch (IOException e) {
              log.error(e.getMessage());
          }
      }
  }
  
  ```

  ![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbyNlXu%2Fbtq6w7UXfUc%2Fsux06qwJwkciw3x6CAxJ30%2Fimg.png)

## 실습 요구사항

### **1. index.html 응답하기**

| 힌트        | 요구사항                                                     |
| ----------- | ------------------------------------------------------------ |
| HTTP Header | GET /index.html HTTP/1.1<br />Connection : keep-alive<br />Accept : */* |
| 1단계       | - InputStream을 한 줄 단위로 읽기 위해 BufferedReader를 생성한다.<br />   - 구글에서 *java inputstream bufferedreader*로 검색 후 문제 해결<br />- BufferedReader.readLine() 메소드를 활용해 라인별로 HTTP 요청 정보를 읽는다.<br />- HTTP 요청 정보 전체를 출력한다.<br />   - 헤더 마지막은 while (!"".equals(line)) {} 로 확인 가능<br />   - line이 null값인 경우에 대한 예외 처리도 해야 함. 그렇지 않을 경우 무한 루프에 빠짐 (if (line == null)) {return;} |
| 2단계       | - HTTP 요청 정보의 첫 번째 라인에서 요청 URL(위 예의 경우 /index.html)을 추출<br />    - String[] tokens = line.split(" "); 를 활용해 문자열을 분리할 수 있음<br />- 구현은 별도의 유틸 클래스를 만들고 단위 테스트를 만들어 진행하면 편함 |
| 3단계       | - 요청 URL에 해당하는 파일을 webapp 디렉토리에서 읽어 전달하면 됨<br />- 구글에서 "java files readallbytes"로 검색해 파일 데이터를 byte[] 로 읽음<br />byte[] body = Files.readAllBytes(new File("./webapp" + url).toPath()); |

**webserver/WebServer **

```java
    public void run() {
        log.debug("New Client Connect! Connected IP : {}, Port : {}", connection.getInetAddress(),
                connection.getPort());

        // InputStream : 클라이언트(웹 브라우저)에서 서버로 요청을 보낼 때 전달되는 데이터를 담당하는 스트림
        // OutputStream : 서버에서 클라이언트에 응답을 보낼 때 전달되는 데이터를 담당하는 스트림
        try (InputStream in = connection.getInputStream();
             OutputStream out = connection.getOutputStream()) {
            // TODO 사용자 요청에 대한 처리는 이 곳에 구현하면 된다.
            /**
             * 2021 - 06 - 04
             * 96p 요구사항 1 - index.html 응답하기
             * http://localhost:8080/index.html로 접속했을 때
             * webapp 디렉토리의 index.html 파일을 읽어 클라이언트에 응답한다.
             * */

            // InputStream을 한 줄 단위로 읽기 위해 BufferedReader를 생성한다
            BufferedReader br = new BufferedReader(new InputStreamReader(in));

            // BufferedReader.readLine() 메소드를 활용해 라인별로 HTTP 요청 정보를 읽는다.
            String line = br.readLine();

            // HTTP 요청 정보의 첫 번째 라인에서 요청 URL을 추출한다.
            String url = getUrl(line);

            // line이 null 값인 경우에 대한 예외 처리도 해야한다.
            // 그렇지 않을 경우 무한 루프에 빠진당
            if (line == null) {
                return;
            }

            // HTTP 요청 정보 전체를 출력한다.
            while(!"".equals(line)) {
                log.info(line);
                line = br.readLine();
            };

            // 요청 URL에 해당하는 파일을 webapp 디렉토리에서 읽어 전달하면 된다
            DataOutputStream dos = new DataOutputStream(out);
            byte[] body = Files.readAllBytes(new File("./webapp" + url).toPath());
            response200Header(dos, body.length);
            responseBody(dos, body);


        } catch (IOException e) {
            log.error(e.getMessage());
        }
    }

    private String getUrl(String line) {
        String url = line.split(" ")[1];
        return url;
    }
```



>### 요약정리
>
>1. **포트번호를 받아옴**
>
>2. **서버 소켓 생성**
>
>   ```java
>   try (ServerSocket listenSocket = new ServerSocket(port)) {}
>   ```
>
>3. **클라이언트가 대기될 때 까지 대기**
>
>   ```java
>   Socket connection;
>   while ((connection = listenSocket.accept()) != null) {}
>   ```
>
>4. **ServerSokect에 사용자 요청이 발생하는 순간 클라이언트와 연결을 담당하는 Socket을 RequestHandler에 전달하면서 새로운 스레드를 실행하는 방식으로 멀티 스레드 프로그래밍을 지원**  
>
>   ```java
>   while ((connection = listenSocket.accept()) != null) {
>       RequestHandler requestHandler = new RequestHandler(connection);
>       requestHandler.start();
>   }
>   ```
>
>5. **`RequestHandler` 는 Thread를 상속받은 클래스. ⬆에서 start() 메소드가 실행됐으니 RequestHandler 클래스의 `run() 메소드`가 실행된다.** [스레드 정리내용](https://github.com/suwampy/TIL/blob/main/java/Thread.md)
>
>6. **RequestHandler 클래스에서는 메인 메소드에서 생성된 socket 객체를 생성자에 주입받는다**
>
>   ```java
>   public RequestHandler(Socket connectionSocket) {
>       this.connection = connectionSocket;
>   }
>   ```
>
>7. **run 메소드에서는 `InputStream`과 `OutputStream`이 생성된다.**
>
>   - InputStream : 클라이언트(웹 브라우저)에서 서버로 `요청`을 보낼 때 전달되는 데이터를 담당하는 스트림
>   - OutputStream :서버에서 클라이언트에 `응답`을 보낼 때 전달되는 데이터를 담당하는 스트림
>
>   ```JAVA
>   try (InputStream in = connection.getInputStream();
>        OutputStream out = connection.getOutputStream()) {}
>   ```
>
>8. **첫 번째 요구사항 - index.html 응답하기**
>
>   8.1   InputStream을 한 줄 단위로 읽기 위해 BufferedReader를 생성한다.
>
>   ```java
>   BufferedReader br = new BufferedReader(new InputStreamReader(in));
>   ```
>
>   8.2 BufferedReader.readLine() 메소드를 활용해 라인별로 HTTP 요청 정보를 읽는다.
>
>   ```java
>   String line = br.readLine();
>   ```
>
>   8.3 HTTP 요청 정보의 첫 번째 라인에서 요청 URL을 추출한다.
>
>   ```java
>   String url = getUrl(line);
>   
>   private String get Url(String line) {
>       String line = line.split("")[1];
>       return url;
>   }
>   ```
>
>   8.4 line이 null 값인 경우에 대한 예외 처리도 해야한다.그렇지 않을경우 무한루프에빠짐
>
>   ```java
>   if (line == null){
>       return;
>   }
>   ```
>
>   8.5 HTTP 요청 정보 전체를 출력한다.
>
>   ```java
>   while(!"". equals(line)){
>       log.info("HTTP request info : {}:", line);
>       line = br.readLine();
>   }
>   ```
>
>   ***log에  http request 정보가 찍힌당....***
>
>   ![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbc7dJH%2Fbtq6zQSlBZF%2F7VN8D6nvrfRq7omA4xeCB1%2Fimg.png)
>
>   8.6 요청 URL에 해당하는 파일을 webapp 디렉토리에서 읽어 전달
>
>   ```java
>   DataOutputStream dos = new DataOutputStream(out);
>   byte[] body = Files.readAllBytes(new File("./webapp" + url).toPath());
>   response200Header(dos, body.length);
>   responseBody(dos, body);
>   ```
>
>   

### 2. GET 방식으로 회원가입하기

'회원가입' 메뉴를 클릭하면 `http://localhost:8080/user/form.html` 로 이동하면서 회원가입 할 수 있다.

| 힌트         | 요구사항                                                     |
| ------------ | ------------------------------------------------------------ |
| HTTP Headerd | GET /user/create?userId=javajigi&password=password&name=JaeSung<br />HTTP/1.1 |
| 1단계        | - InputStream을 한 줄 단위로 읽기 위해 BufferedReader를 생성한다.<br />   - 구글에서 *java inputstream bufferedreader*로 검색 후 문제 해결<br />- BufferedReader.readLine() 메소드를 활용해 라인별로 HTTP 요청 정보를 읽는다.<br />- HTTP 요청 정보 전체를 출력한다.<br />   - 헤더 마지막은 while (!"".equals(line)) {} 로 확인 가능<br />   - line이 null값인 경우에 대한 예외 처리도 해야 함. 그렇지 않을 경우 무한 루프에 빠짐 (if (line == null)) {return;} |
| 2단계        | - HTTP 요청 정보의 첫 번째 라인에서 요청 URL(위 예의 경우 /index.html)을 추출<br />    - String[] tokens = line.split(" "); 를 활용해 문자열을 분리할 수 있음<br />- 구현은 별도의 유틸 클래스를 만들고 단위 테스트를 만들어 진행하면 편함 |
| 3단계        | - 요청 URL에 해당하는 파일을 webapp 디렉토리에서 읽어 전달하면 됨<br />- 구글에서 "java files readallbytes"로 검색해 파일 데이터를 byte[] 로 읽음<br />byte[] body = Files.readAllBytes(new File("./webapp" + url).toPath()); |
