## 01.  프로세스의 개요

### 1. 프로세스의 개념

프로그램과 프로세스를 비교했을 때 프로그램은 저장장치에 저장되어 있는 정적인 상태이고, **프로세스**는 실행을 위해 메모리에 올라온 동적인 상태이다.

| 프로그램                                                   | 프로세스                                                     |
| ---------------------------------------------------------- | ------------------------------------------------------------ |
| 저장장치에 저장되어있는 정적인 상태                        | 실행을 위해 메모리에 올라온 동적인 ㅅ아태                    |
| 데이터를 사용하여 어떤 작업을 할 지 **그 절차를 적어놓음** | **'실행한다'**로 표현, 프로그램에 작성된 작업 절차를 실제로 실행에 옮김 |



### 2. 요리사 모형에의 비유

'재료를 준비하고 다듬는 단계'

'재료를 볶거나 튀기는 등 조리를 하는 단계'

'완성된 음식을 그릇에 담는 단계'

1. **주문서의 역할**
   - 주문서는 요리의 전반적인 조리 방법과 요리가 나가는 순서를 결정하는 중요한 자료
   - 주문서가 주방에 전달되면 요리사는 주문서에 적힌 대로 요리를 하여 손님에게 제공
2. **일괄 작업 방식의 요리**
   - 테이블이 하나밖에 없음
   - 주방에서는 주문서가 도착한 순서대로 요리를 하기 위해 ''주문 목록''을 사용하는데 이 주문목록은 **큐(queue)** 로 처리됨
3. **시분할 방식의 요리**
   - 시간을 적당히 배분하여 여러가지 요리를 동시에 함
   - CPU가 1개인 컴퓨터에서 여러 개의 프로세스를 동시에 실행하는 것도 같은 원리



### 3. 프로그램에서 프로세스로의 전환

프로세스는 컴퓨터 시스템의 작업 단위로 **태스크** 라고도 부름

#### 👉 시분할 방식 시스템에서 프로그램이 프로세스로 전환될 때

- 운영체제는 프로그램을 메모리의 적당한 위치로 가져옴

- **작업 지시서(프로세스 제어 블록)**를 만듦 (레스토랑의 예에서 주문서에 해당)

  > **프로세스 제어 블록?** : 운영체제가 해당 프로세스를 위해 관리하는 자료 구조
  >
  > 어떤 프로그램이 **프로세스** 되었다 👉 운영체제로부터 **프로세스 제어 블록**을 받았다
  >
  > - 프로세스 구분자 : 각 프로세스를 구분하는 구분자
  > - 메모리 관련 정보 : 프로세스의 메모리 위치 정보
  > - 각종 중앙값 : 프로세스가 사용했던 중간값

- 프로세스가 종료되면 프로세스가 메모리에서 삭제되고 프로세스 제어 블록도 폐기됨



#### 👉 프로세스와 프로그램의 관계

**프로세스** = 프로그램 + 프로세스 제어블록

**프로그램** = 프로세스 - 프로세스 제어 블록



#### 👉 컴퓨터 내에 사용자가 실행한 프로세스만 있는 것은 아님

- 운영체제도 프로그램이기 떄문에 프로세스 형태로 실행
- 부트스트랩 : 운영체제 프로세스를 메모리에 올리는 프로그램
  - 운영체제 관련 프로세스를 실행한 후 일반 프로세스가 실행됨
  - 컴퓨터에는 일반 사용자의 사용자 프로세스와 운영체제의 커널 프로세스가 섞여서 실행됨



### 4. 프로세스의 상태

#### 👉 프로세스의 네 가지 상태

- **생성 상태** : 프로세스가 메모리에 올라와 실행 준비를 완료한 상태. 프로세스를 관리하는데 필요한 프로세스 제어 블록이 생성됨
- **준비 상태** : 생성된 프로세스가 CPU를 얻을 떄까지 기다리는 상태
- **실행 상태** : 준비 상태에 있는 프로세스 중 하나가 CPU를 얻어 실제 작업을 수행하는 상태
- **완료 상태** : 실행 상태의 프로세스가 주어진 시간 동안 작업을 마치면 완료 상태로 진입



#### 👉 CPU 스케줄러의 역할

- 준비 상태에 있는 여러 프로세스 중 다음에 실행할 프로세스를 선정
- **디스패치** : 준비 상태의 프로세스 중 하나를 골라 실행 상태로 바꾸는 CPU 스케줄러의 작업
- **타임 슬라이스/타임 퀸텀** : 프로세스에 배당된 작업 시간
- **타임 아웃** : 타임 슬라이스 동안 작업을 끝내지 못했을 때 다시 준비상태로 돌아감



#### 👉 프로세스의 다섯 가지 상태

- **대기 상태** : 입출력을 요구한 프로세스가 입출력이 완료될 때까지 기다리는 상태
- 입출력을 요청한 프로세스가 대기 상태로 옮겨지면 CPU 스케줄러는 준비 상태에 있는 프로세스 중 하나를 가져다 실행 상태로 만듦

![](https://mblogthumb-phinf.pstatic.net/MjAxOTAzMjhfMjg4/MDAxNTUzNjk5MjY1ODkx.k-oHEs3KEMZDTLmb678h-0-uJRkfgCzWB6TM_zjF17Ag.NB8NohYuKuR-l-zBAszogUDDUmVabHYJWOy3WX_NHh8g.PNG.ahn128/image.png?type=w800)

- **생성 상태** 
  - 프로그램이 메모리에 올라오고 운영체제로부터 프로세스 제어 블록을 할당받은 상태
  - 생성된 프로세스는 바로 실행되는 것이 아니라 준비 상태에서 자기 순서를 기다리며, 프로세스 제어 블록도 같이 준비 상태로 옮겨짐
  - **메모리 할당, 프로세스 제어 블록 생성**
- **준비 상태**
  - 실행을 기다리는 모든 프로세스가 자기 차례를 기다리는 상태
  - 프로세스 제어 블록은 준비 큐에서 기다리며 CPU 스케줄러에 의해 관리됨
  - 실행될 프로세스를 CPU 스케줄러가 선택
  - **dispatch(PID): 준비->실행**
- **실행 상태**
  - 선택된 프로세스가 타입 슬라이스를 얻어 CPU를 할당받아 사용하는 상태
  - 실행 상태에 있는 프로세스는 자신에게 주어진 시간 동안만 작업할 수 있음
  - **timeout(PID):실행->준비** : 프로세스 제어 블록을 실행 상태에서 준비 상태로 옮김
  - **exit(PID):실행->완료** : 실행 상태 동안 작업이 완료되면 exit(PID)가 실행되어 프로세스가 정상 종료됨
  - **block(PID):실행->대기** : 실행 상태에 있는 프로세스가 입출력을 요청하면 block(PID)를 실행. block(PID)는 해당 프로세스를 대기로 옮김

- **대기 상태**
  - 실행 상태에 있는 프로세스가 입출력을 요청하면 입출력이 완료될 때까지 기다리는 상태
  - 입출력이 완료되면 준비 상태로 감
- **완료 상태**
  - 프로세스가 종료되는 상태
  - 코드와 사용했던 데이터를 메모리에서 삭제하고 프로세스 제어 블록을 폐기



#### 👉 휴식 상태와 보류 상태

- **휴식 상태**
  - 프로세스가 작업을 일시적으로 쉬고 있는 상태

- **보류 상태**

  - 프로세스가 메모리에서 잠시 쫓겨난 상태

  - 일시정지 상태라고도 불리며, 보류 상태와 비교하여 일반적인 프로세스 상태를 활성 상태라고 함

    ![](https://mblogthumb-phinf.pstatic.net/MjAxOTAzMjhfMTY4/MDAxNTUzNjk5NDA4MzA0.X1YArDvvtPk_4_duJ7unZmzn9roPhVAkr8rE0ElEyM0g.gx9wHHnhY31V7uYeSSLFPrQR9bIC5yiab4s_2KfZsPwg.PNG.ahn128/image.png?type=w800)

    
