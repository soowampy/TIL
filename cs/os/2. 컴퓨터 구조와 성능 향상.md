## 01. 컴퓨터의 기본 구성

### 1. 하드웨어의 구성

컴퓨터는 중앙처리장치(CPU), 메인메모리, 입력장치, 출력장치, 저장장치로 구성된다.

#### 👉 CPU와 메모리

- **CPU**는 명령을 해석하여 실행하는 장치로 인간으로 치면 두뇌에 해당한다.

- **메모리**는 작업에 필요한 프로그램과 데이터를 저장하는 장소로, 바이트 단위로 분할되어 있으며 분할 공간마다 주소로 분리한



#### 👉 입출력장치

- **입력장치** 는 외부의 데이터를 컴퓨터에 입력하는 장치이다.

- **출력장치** 는 컴퓨터에서 처리한 결ㄹ과를 사용자가 원하는 형태로 출력하는 장치이다.

  

#### 👉 저장장치

- **저장장치**는 메모리보다 느리지만 저렴하고 용량이 크며, 전원 온,오프와 상관없이 데이터를 영구적으로 저장한다. 느린 저장 장치를 사용하는 이유는 가격이 싸기 때문이다.

  

#### 👉 메인보드

- **메인보드**는 CPU와 메모리 등 다양한  부품을 연결하는 커다란 판이다.



### 2. 폰노이만 구조

**폰노이만 구조**는 CPU, 메모리, 입출력장치, 저장장치가 버스로 연결되어있는 구조를 말한다. 오늘날의 컴퓨터는 대부분 폰노이만 구조를 따른다.

<img src="https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F99658C505B94DE1E32" style="zoom:50%;" />

👀 메모리를 이용하여 프로그래밍이 가능한 컴퓨터 구조, 즉 하드웨어는 그대로 둔 채 작업을 위한 프로그램만 교체하여 메모리에 올리는 방식

폰노이만 구조에서 가장 중요한 특징은 **`모든 프로그램은 메모리에 올라와야 실행할 수 있다` **는 것이다.



### 3. 요리사 모형

![](https://mblogthumb-phinf.pstatic.net/MjAxOTAzMjZfMTQw/MDAxNTUzNTk2Mjg1NTkw.3dprBeOsTVm6VDvdfgCaR_TZ6DO6FiehuAbkZgTyng8g._xZwxg8rAoQ4S9KV90VGdPqAFrYgsqf_GJrL0RmFQtsg.PNG.ahn128/image.png?type=w800)

이 모형에서 **요리사**는 `CPU`, **도마**는 `메모리`, **보관창고**는 `저장장치`에 비유되며 보관 창고에 있는 재료를 도마로 옮겨주는 주방 보조, 채소를 다듬거나 고기를 손질하는 보조 요리사도 있다.

- **요리사** `(CPU)`가 요리를 하려면 **보관 창고** `(저장장치)`에 있는 재료를 **도마** `(메모리)` 로 가져와야한다.

- 주방에서는 **도마** `(메모리)` 가 핵심적인 작업 공간이고  **보관 창고** `(저장장치)` 는 보조적인 공간이다.

- **요리사 모형과 운영체제 작업의 비교**

  | 요리사 모형    | 운영체제 작업 |
  | -------------- | ------------- |
  | 요리 방법 결정 | 프로세스 관리 |
  | 도마 정리      | 메모리 관리   |
  | 보관 창고 정리 | 저장장치 관리 |

  



### 4. 하드웨어 사양 관련 용어

#### 👉 클록

- 클록은 **CPU의 속도**와 관련된 단위이다.

- 클록이 일정 간격으로 틱을 만들면 거기에 맞추어 CPU안의 모든 구성 부품이 작업을 한다.



#### 👉 헤르츠

- 헤르츠는 **클록틱이 발생하는 속도**를 나타내는 단위이다.

- 1초에 클록틱이 한 번이면 1Hz, 1,000번이면 1kHz(1,000Hz) 이다.



#### 👉 시스템 버스와 CPU 내부 버스

- **시스템 버스**는 메모리와 주변장치를 연결하는 버스로 FSB(Front-Side Bus) 즉 전면버스라고 한다.
- **CPU 내부 버스**는 CPU 내부에 있는 장치를 연결하는 버스로 BSB(Back Side Bus), 즉 후면 버스라고 한다. CPU 내부 버스는 시스템 버스보다 훨씬 빠름



## 02. CPU와 메모리

### 1. CPU의 구성과 동작

#### 👉 CPU의 기본 구성

CPU는 명령어를 해석하여 실행하는 장치

CPU는 산술논리 연산장치, 제어장치, 레지스터로 구성되며 이것들의 엽헙으로 작업을 처리한다

- **산술논리 연산장치**

  CPU에서 데이터를 연산하는 장치

  산술논리 연산장치는 데이터의 덧셈, 뺄셈, 곱셈, 나눗셈과 같은 산술 연산과 AND, OR 같은 논리 연산을 수행한다.

- **제어장치**

  CPU에서 작업을 지시하는 부분

- **레지스터**

  CPU 내에 데이터를 임시로 보관하는 곳

  

#### 👉 CPU의 명령어 처리 과정

**C 언어로 작성한 덧셈 프로그램**

```c
int D2=2, D3=3, sum;
sum= D2+D3;
```



CPU는 0과 1의 2진수로 이루어진 기계어만 인식

따라서 위 코드를 실행하려면 **컴파일러** 를 이용하여 **기계어** 로 바꾸어야 함



**어셈블리어로 변환한 덧셈 프로그램**

```assembly
LOAD mem(100), register 2;
LOAD mem(200), register 3;
ADD register 5, register 2, register 3;
MOVE register 5, mem(160);
```

- CPU가 연산을 하려면 필요한 데이터를 CPU로 가져와 임시로 보관해야 하는데, 이때 사용되는 장소가 레지스터
- 제어장치는 명령어를 해석하여 제어 신호를 보내고 CPU 내의 데이터 흐름을 조절하는 역할을 함 

![](https://mblogthumb-phinf.pstatic.net/MjAxOTAzMjZfMTky/MDAxNTUzNTk2OTM2NDE5.e_VD72jJdIG4ntiEpmFlKzrY-D_MfpzU6VWCn3ZpBC4g.hWOlYoCcWIcremPcBG6kQtGDODRs1p31ZzjMnZ_oQ5gg.PNG.ahn128/image.png?type=w800)





#### 👉 레지스터의 종류

CPU는 필요한 데이터를 메모리에서 가져와 레지스터에 저장하고 산술놀리 연상장치를 이요하여 연산을 한 후, 그 결과를 다시 레지스터에 저장했다가 메모리로 옮김

- **사용자 가시 레지스터** : 사용자 프로그램에 의해 변경됨
  - **데이터 레지스터(DR)** : 메모리에서 가져온 데이터를 임시로 보관할 때 사용
  - **주소 레지스터(AR)** : 데이터 또는 명령어가 저장된 메모리의 주소는 주소 레지스터에 저장 됨

- **특수 레지스터** : 데이터 레지스터와 주소 레지스터 외에 특별한 용도로 사용됨. 사용자가 임의로 변경할 수 없음
  - **프로그램 카운터(PC)** : 다음에 실행할 명령어의 주소를 기억하고 있다가 제어장치에 알려줌
  - **명령어 레지스터(IR)** : 현재 실행 중인 명령어를 저장. 제어 장치는 명령어 레지스터에 있는 명령을 해석한 후 외부 장치에 적절한 제어 신호를 보냄
  - **메모리 주소 레지스터(MAR)** : 메모리에서 데이터를 가져오거나 반대로 메모리로 데이터를 보낼 때 주소를 지정하기 위해 사용
  - **메모리 버퍼 레지스터(MBR)** : 메모리에서 가져온 데이터나 메모리로 옮겨갈 데이터를 임시 저장

![](https://mblogthumb-phinf.pstatic.net/MjAxOTAzMjZfMjYw/MDAxNTUzNTk3MDM4MTMx.TS-ahs_jpPU5K2VGkjtKwGWYBMaYjUoUDyU9EH3BcOEg.jlWjoVookTkr3ntNKfyjyxTwgOh0z_bLhQyM7G-gGjwg.PNG.ahn128/image.png?type=w800)



#### 👉 버스의 종류

![](https://mblogthumb-phinf.pstatic.net/MjAxOTAzMjZfMTcx/MDAxNTUzNTk3MTIwNjY4.GfXY6GiGFknKmMuI4AxYf2yLzVoTSlDfo3HGe05zZvkg.w70Pvr9QtBCkDI1F9Xa6wt4aURfktKnJOQhcqej0RxUg.PNG.ahn128/image.png?type=w800)



- **🚌 제어 버스** : 제어장치와 연결된 버스로, CPU가 메모리와 주변 장치에 제어 신호를 보내기 위해 사용함

  - 제어 버스에서는 **다음에 `어떤 작업을 할지` 지시하는 제어 신호가 오고 간다.**

  - 메모리에서 데이터를 가져올 때는 읽기 신호를 보내고, 처리한 데이터를 메모리로 옮겨놓을 때는 쓰기 신호를 보낸다.

  - 주변 장치의 경우 하드디스크에 저장 명령을 내리거나 사운드카드에 소리를 내라는 명령을 내릴 때 제어 버스를 통해 전달

  - 제어 버스는 CPU의 제어장치와 연결되어있고, 제어 버스의 신호는 CPU, 메모리, 주변장치와 양방향으로 오고 간다.

    

- **🚌 주소 버스** : 메모리 주소 레지스터와 연결된 버스로, 메모리나 주변장치에 데이터를 읽거나 쓸 때 위치 정보를 보내기 위해 사용

  - 주소 버스에서는 **메모리의 데이터를 읽거나 쓸 때 `어느 위치에서 작업할 것인지`를 알려주는 위치 정보(주소)가 오고 간다.**

  - 주변 장치의 경우 하드디스크의 어느 위치에서 데이터를 읽어올지, 어느 위치에 저장할지에 대한 위치 정보가 주소 버스를 통해 전달됨

  - 주소 버스는 메모리 주소 레지스터와 연결되어 있으며 단반향

  - CPU에서 메모리나 주변장치로 나가는 주소 정보는 있지만 주소 버스를 통해 CPU로 전달되는 정보는 없음

    

- 🚌 **데이터 버스**
  - 메모리 버퍼 레지스터와 연결된 버스
  - 데이터의 이동이 양방향으로 이루어짐



- **버스의 대역폭** : 한 번에 전달할 수 있는 데이터의 최대 크기 = CPU가 한 번에 처리할 수 있는 데이터의 크기

  - 32bit CPU : 메모리에서 데이터를 읽거나 쓸 때 한 번에 최대 32bit를 처리
  - 버스의 대역폭, 레지스터의 크기, 메모리에 한 번 저장할 수 있는 데이터의 크기는 항상 같음
  - 단위 = 워드(word), 32bit CPU에서 1워드는 32bit

  

### 2. 메모리 종류와 부팅

모든 프로그램은 메모리에 올라와야 실행될 수 있다.

메모리에는 실행에 필요한 프로그램과 데이터가 존재하며, CPU와 협업하여 작업이 이루어진다.



#### 👉 메모리의 종류

![](https://mblogthumb-phinf.pstatic.net/MjAxOTAzMjZfOTUg/MDAxNTUzNTk3MjM3NDI3.ukM0NYqFWtzosl9-oaPX1zEVRTpe0R3LSajH7Hsfh7Qg.Cn-nzTOubBBRO8qMm898SC1wItw8fStpZC8Q6Ct6Ytwg.PNG.ahn128/image.png?type=w800)

- **휘발성 메모리** : 전력이 끊기면 데이터가 사라짐. 메인 메모리로 사용

  - **DRAM (동적 램)** : 저장된 0과 1의 데이터가 일정 시간이 지나면 사라지므로 일정 시간마다 다시 재새잇켜야 함

  - **SRAM (정적 램)** : 전력이 공급되는 동안에는 데이터를 보관할 수 있어 재생할 필요가 없음

    

- **비휘발성 메모리** : 전력이 끊겨도 데이터를 보관할 수 있음
  - **플래시메모리**
  - **FRAM**
  - **PRAM**



#### 👉 메모리 보호

- 운영체제도 CPU를 사용하는 작업 중 하나기 때문에 사용자의 작업이 진행되는 동안에는 **운영체제의 작업이 잠시 중단됨** 

- 운영체제의 작업이 중단된 상태에서 사용자의 작업으로부터 메모리를 보호하려면 **하드웨어의 도움이 필요**

- 메모리를 보호하기 위해 **CPU는 현재 진행 중인 작업의 메모리 시작 주소를 `경계 레지스터`에 저장**한 후 작업, **마지막 주소까지의 차이를 `한계 레지스터`에 저장**

- 사용자의 작업이 진행되는 동안 이 **두 레지스터 (경계 레지스터, 한계 레지스터)의 주소 범위를 벗어나는지 하드웨어적으로 점검함으로써 메모리를 보호**

- 두 레지스터의 값을 벗어난다면 **메모리 오류와 관련된 인터럽트 발생**, 모든 작업이 중단되고 CPU는 운영체제를 깨워서 인터럽트를 처리하도록 시킴

  

#### 👉 부팅

컴퓨터를 켰을 떄 운영체제를 메모리에 올리는 과정을 **부팅**이라고 함

![](https://mblogthumb-phinf.pstatic.net/MjAxOTAzMjZfNzcg/MDAxNTUzNTk3NjQ5ODg3.GMLd3qRK1ZRzaLWo9gbva2VUWlQmObJkP_t2BNRNlHAg.YgCn8c-vRPJVjvkQCi4tqwGguR8bJX1eJ54nVPwBXv0g.PNG.ahn128/image.png?type=w800)



1. 롬에 저장된 바이오스가 실행됨

2. 바이오스는 CPU, 메모리, 하드디스크, 키보드, 마우스와 같은 주요 하드웨어가 제대로 작동하는지 확인

3. 이상이 없으면 하드디스크의 **마스터 부트 레코드**에 저장된 작은 프로그램을 메모리에 가져와 실행

   > **마스터 부트 레코드**
   >
   > - 하드디스크의 첫 번쨰 섹터를 가리킴
   > - 운영체제를 실행하기 위한 코드인 부트스트랩(bootstrap) 이 저장되어 있음 (부트스트랩 코드 : 운영체제를 메모리로 가져와 실행하는 역할을 하는 작은 프로그램)

4. 마스터 부트 레코드에 있는 부트스트트랩이 메모리에 올라오면 하드디스크에 저장된 운영체제를 메모리에 불러옴



## 03. 컴퓨터 성능 향상 기술

### 1. 버퍼

버퍼는 속도에 차이가 있는 두 장치 사이에서 그 차이를 완화하는 역할을 함

일정량의 데이터를 모아 옮김으로써 속도의 차이를 완화하는 장치



### 2. 캐시

캐시는 메모리와 CPU간의 속도 차이를 완화하기 위해 메모리의 데이터를 미리 가져와 저장해두는 임시 저장소

캐시는 필요한 데이터를 모아 한꺼번에 전달하는 버퍼의 일종으로 CPU가 앞으로 사용할 것으로 예상되는 데이터를 미리 가져다놓음

- **캐시의 구조**
  - 캐시 히트 : 캐시에서 원하는 데이터를 찾았을 때. 데이터를 바로 사용함
  - 캐시 미스 : 원하는 데이터가 캐시에 없을 때. 메모리에 가서 데이터를 찾음
  - 캐시 적중률 : 캐시 히트가 되는 비율. 일반적인 컴퓨터의 캐시 적중률은 약 90%. 컴퓨터의 성능을 향상하려면 캐시 적중률이 높아야 함
- **즉시 쓰기와 지연 쓰기** 
  - 즉시 쓰기 : 캐시에 있는 데이터가 변경되면 이를 즉시 메모리에 반영하는 방식.  성능이 느리다는 단점이 있지만 데이터를 잃어버리지 않음
  - 지연 쓰기 : 캐시에 있는 데이터가 변경되면 변경된 내용을 모아서 주기적으로 반영하는 방식. 카피백 이라고도 함. 성능을 향상할 수 있으나 메모리와 캐시된 데이터 사이에 불일치가 발생할 수도 있음
- **L1캐시와 L2캐시**
  - 프로그램의 명령어는 크게 어떤 작업을 할지 나타내는 **명령어 부분**과 작업 대상인 **데이터 부분**으로 나눌 수 있다
  - 캐시는 명령어와 데이터의 구분 없이 모든 자료를 가져오는 **일반 캐시**(L2), 명령어와 데이터를 구분하여 가져오는 **특수 캐시**(L1)로 구분된다



### 3. 인터럽트

입출력 관리자가 CPU에 보내는 완료 신호를 인터럽트라고 한다.

인터럽트 방식은 CPU의 작업과 저장장치의 데이터 이동을 독립적으로 운영함으로써 시스템의 효율을 높인다.

인터럽트 방식에서는 많은 주변장치 중 어떤 것의 작업이 끝났는지를 CPU에 알려주기 위해 **인터럽트 번호** 를 사용한다.

#### 👉 인터럽트 방식의 동작 과정

1. CPU가 입출력 관리자에게 입출력 명령을 보낸다
2. 입출력 관리자는 명령받은 데이터를 메모리에 가져다놓거나 메모리에 있는 데이터를 저장장치로 옮긴다.
3. 데이터 전송이 완료되면 입출력 관리자는 완료 신호를 CPU에 보낸다.



#### 👉 직접 메모리 접근

- 입출력 관리자가 CPU의 허락 없이 메모리에 접근할 수 있는 권한
- 메모리는 CPU의 작업 공간이지만, 데이터 전송을 지시받은 입출력 관리자는 직접 메모리 접근 권한이 있어야만 작업을 처리할 수 있음



## 04. 병렬 처리

병렬 처리는 동시에 여러 개의 명령을 처리하여 작업의 능률을 올리는 방식을 말한다

### 1. 병렬 처리 시 고려사항

- 상호 의존성이 없어야 병렬 처리가 가능하다.
- 각 단계의 시간을 거의 일정하게 맞춰야 병렬 처리가 원만하게 이루어진다.
- 전체 작업 시간을 몇 단계로 나눌지 잘 따져보아야 한다.



### 2. 병렬 처리 기법

CPU 내에서 명령어는 제어장치가 처리한다.

제어장치는 명령어를 가져와 해석한 후 실행하고 결과를 저장하는 과정을 계속 반복한다.

=> 이러한 과정 전체를 하나의 **스레드** 라고 하며, 스레드를 이루는 각 단계는 CPU의 클록과 연결되어 한 클록에 한 번씩 이루어진다



> **CPU에서 명령어가 실행되는 과정**
>
> 1. 명령어 패치 : 다음에 실행할 명령어를 명령어 레지스터에 저장
> 2. 명령어 해석 : 명령어를 해석
> 3. 실행 : 해석한 결과를 토대로 명령어를 실행
> 4. 쓰기 : 실행된 결과를 메모리에 저장



#### 👉 파이프 라인 기법

파이프라인 기법은 CPU의 사용을 극대화하기 위해 명령을 겹쳐서 실행하는 방법으로 CPU의 사양과 연관지어 보면 하나의 코어에 여러 개의 스레드를 사용하는 것

파이프라인 기법에서는 명령어를 여러 개의 단계로 분할한 후, 각 단계를 동시에 처리하는 하드웨어를 독립적으로 구성

- **파이프라인 위험**
  - 데이터 위험 : 데이터의 의존성 떄문에 발생
  - 제어 위험 : 분기를 하는 if 문 또는 바로가기의 goto 문 같은 명령에서 발생
  - 구조 위험 : 서로 다른 명령어가 같은 자원에 접근하려 할 때 발생



#### 👉 슈퍼스칼라 기법 

파이프라인을 처리할 수 있는 코어를 여러 개 구성하여 복수의 명령어가 동시에 실행되도록 하는 방식

