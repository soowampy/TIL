
- 트랜잭션 : 작업의 완전성을 보장해 줌. 데이터의 정합성을 보장하기 위한 기능
- 잠금 : 동시성을 제어하기 위한 기능.
  - 여러 커넥션에서 동시에 동일한 자원을 요청할 경우
  - 순서대로 **한 시점에는 하나의 커넥션만** 변경할 수 있게 해주는 역할을 함
- 트랜잭션 : 데이터의 정합성을 보장하기 위한 기능

# **1. 트랜잭션**

## **1. MySQL에서의 트랜잭션**

- 트랜잭션은 논리적인 작업 셋 자체가 100% 적용 되거나
- 아무것도 적용되지 않아야 함을 보장해주는 것

> e.g InnoDB 테이블과 MyISAM 테이블의 차이

```
INSERT INTO tab_myisam (fdpk) VALUES (3);
INSERT INTO tab_innodb (fdpk) VALUES (3);

INSERT INTO tab_myisam (fdpk) VALUES (1), (2), (3);
INSERT INTO tab_innodb (fdpk) VALUES (1), (2), (3);
SELECT * FROM tab_myisam;
+------+
| fdpk |
+------+
|    1 |
|    2 |
|    3 |
+------+

SELECT * FROM tab_innodb;
+------+
| fdpk |
+------+
|    3 |
+------+
```

- 두 INSERT 문장 모두 프라이머리 키 중복 오류로 쿼리 실패
- MyISAM
  - 오류가 발생했음에도 '1'과 '2'는 INSERT된 상태로 남아있음
  - 1 -> 2 -> 3 저장 순간 오류 발생
  - 1과 2를 그대로 두고 쿼리 실행 종료
- InnoDB
  - **쿼리 중 일부라도 오류가 발생하면 전체를 원 상태로 만든다**는 트랜잭션의 원칙을 지킴
  - INSERT 문장을 실행하기 전 상태로 그대로 복구

## **2. 주의사항**

- 트랜잭션은 꼭 필요한 최소의 코드에만 적용하는 것이 좋음
- 트랜잭션의 범위를 최소화 하자

> e.g 사용자가 게시판에 게시물을 작성한 후 저장 버튼을 클릭헀을 때 서버에서 처리하는 내용을 정리
>
> 1. 처리 시작
>    - 데이터베이스 커넥션 생성
>    - 트랜잭션 시작
> 2. 사용자의 로긍니 여부 확인
> 3. 사용자의 글쓰기 내용의 오류 여부 확인
> 4. 첨부로 업로드된 파일 확인 및 저장
> 5. 사용자의 입력 내용을 DBMS에 저장
> 6. 첨부 파일 정보를 DBMS에 저장
> 7. 저장된 내용 또는 기타 정보를 DBMS에서 조회
> 8. 게시물 등록에 대한 알림 메일 발송
> 9. 알림 메일 발송 이력을 DBMS에 저장
>    - 트랜잭션 종료 (COMMIT)
>    - 데이터베이스 컨게션 반납
> 10. 처리 완료

- 커넥션 생성 작업을 1번과 2번 사이에 구현, 9번과 10번 사이에서 commit하고 커넥션을 종료..
  - 좋지 않음!
  - 실제로 DBMS에 데이터를 저장하는 작업에서 5번부터 시작됨
  - 데이터베이스 커넥션은 개수가 제한적이어서
  - 각 단위의 프로그램이 커넥션을 소유하는 시간이 길어질수록
  - 사용 가능한 여유 커넥션 개수는 줄어들 것
- 8번작업 -> 위험
  - 메일 전송같은 네트워크를 통해 원격 서버와 통신하는 등과 같은 작업은
  - DBMS의 트랜잭션 내에서 제거하는 것이 좋음
- 사용자가 입력한 정보를 저장하는 5번과 6번 작업은 반드시 하나의 트랜잭션으로 묶어야 함
- 7번은 트랜잭션에 포함할 필요는 없음
- 9번은 이전 트랜잭션(5, 6)과 함께 묶지 않아도 됨

> 다시 설계
>
> 1. 처리 시작
> 2. 사용자의 로긍니 여부 확인
> 3. 사용자의 글쓰기 내용의 오류 여부 확인
> 4. 첨부로 업로드된 파일 확인 및 저장
>    - 데이터베이스 커넥션 생성 (또는 커넥션 풀에서 가져오기)
>    - 트랜잭션 시작
> 5. 사용자의 입력 내용을 DBMS에 저장
> 6. 첨부 파일 정보를 DBMS에 저장
>    - 트랜잭션 종료
> 7. 저장된 내용 또는 기타 정보를 DBMS에서 조회
> 8. 게시물 등록에 대한 알림 메일 발송
>    - 트랜잭션 시작
> 9. 알림 메일 발송 이력을 DBMS에 저장
>    - 트랜잭션 종료 (COMMIT)
>    - 데이터베이스 커넥션 반납
> 10. 처리 완료

- 프로그램의 코드가 데이터베이스 커넥션을 가지고 있는 범위와 트랜잭션이 활성화돼 있는 프로그램의 범위를 최소화 하자!

# **2. MySQL 엔진의 잠금**

- MySQL에서 사용되는 잠금은 다음과 같이 나뉘어진다
  - 스토리지 엔진 레벨
    - 스토리지 엔진 간 상호 영향을 미치지는 않음
  - MySQL 엔진 레벨
    - 스토리지 엔진을 제외한 나머지 부분
    - 모든 스토리지 엔진에 영향을 미침

### **1. 글로벌 락**

# **5장 트랜잭션과 잠금**

- 트랜잭션 : 작업의 완전성을 보장해 줌. 데이터의 정합성을 보장하기 위한 기능
- 잠금 : 동시성을 제어하기 위한 기능.
  - 여러 커넥션에서 동시에 동일한 자원을 요청할 경우
  - 순서대로 **한 시점에는 하나의 커넥션만** 변경할 수 있게 해주는 역할을 함
- 트랜잭션 : 데이터의 정합성을 보장하기 위한 기능

# **1. 트랜잭션**

## **1. MySQL에서의 트랜잭션**

- 트랜잭션은 논리적인 작업 셋 자체가 100% 적용 되거나
- 아무것도 적용되지 않아야 함을 보장해주는 것

> e.g InnoDB 테이블과 MyISAM 테이블의 차이

```
INSERT INTO tab_myisam (fdpk) VALUES (3);
INSERT INTO tab_innodb (fdpk) VALUES (3);

INSERT INTO tab_myisam (fdpk) VALUES (1), (2), (3);
INSERT INTO tab_innodb (fdpk) VALUES (1), (2), (3);
SELECT * FROM tab_myisam;
+------+
| fdpk |
+------+
|    1 |
|    2 |
|    3 |
+------+

SELECT * FROM tab_innodb;
+------+
| fdpk |
+------+
|    3 |
+------+
```

- 두 INSERT 문장 모두 프라이머리 키 중복 오류로 쿼리 실패
- MyISAM
  - 오류가 발생했음에도 '1'과 '2'는 INSERT된 상태로 남아있음
  - 1 -> 2 -> 3 저장 순간 오류 발생
  - 1과 2를 그대로 두고 쿼리 실행 종료
- InnoDB
  - **쿼리 중 일부라도 오류가 발생하면 전체를 원 상태로 만든다**는 트랜잭션의 원칙을 지킴
  - INSERT 문장을 실행하기 전 상태로 그대로 복구

## **2. 주의사항**

- 트랜잭션은 꼭 필요한 최소의 코드에만 적용하는 것이 좋음
- 트랜잭션의 범위를 최소화 하자

> e.g 사용자가 게시판에 게시물을 작성한 후 저장 버튼을 클릭헀을 때 서버에서 처리하는 내용을 정리
>
> 1. 처리 시작
>    - 데이터베이스 커넥션 생성
>    - 트랜잭션 시작
> 2. 사용자의 로긍니 여부 확인
> 3. 사용자의 글쓰기 내용의 오류 여부 확인
> 4. 첨부로 업로드된 파일 확인 및 저장
> 5. 사용자의 입력 내용을 DBMS에 저장
> 6. 첨부 파일 정보를 DBMS에 저장
> 7. 저장된 내용 또는 기타 정보를 DBMS에서 조회
> 8. 게시물 등록에 대한 알림 메일 발송
> 9. 알림 메일 발송 이력을 DBMS에 저장
>    - 트랜잭션 종료 (COMMIT)
>    - 데이터베이스 컨게션 반납
> 10. 처리 완료

- 커넥션 생성 작업을 1번과 2번 사이에 구현, 9번과 10번 사이에서 commit하고 커넥션을 종료..
  - 좋지 않음!
  - 실제로 DBMS에 데이터를 저장하는 작업에서 5번부터 시작됨
  - 데이터베이스 커넥션은 개수가 제한적이어서
  - 각 단위의 프로그램이 커넥션을 소유하는 시간이 길어질수록
  - 사용 가능한 여유 커넥션 개수는 줄어들 것
- 8번작업 -> 위험
  - 메일 전송같은 네트워크를 통해 원격 서버와 통신하는 등과 같은 작업은
  - DBMS의 트랜잭션 내에서 제거하는 것이 좋음
- 사용자가 입력한 정보를 저장하는 5번과 6번 작업은 반드시 하나의 트랜잭션으로 묶어야 함
- 7번은 트랜잭션에 포함할 필요는 없음
- 9번은 이전 트랜잭션(5, 6)과 함께 묶지 않아도 됨

> 다시 설계
>
> 1. 처리 시작
> 2. 사용자의 로긍니 여부 확인
> 3. 사용자의 글쓰기 내용의 오류 여부 확인
> 4. 첨부로 업로드된 파일 확인 및 저장
>    - 데이터베이스 커넥션 생성 (또는 커넥션 풀에서 가져오기)
>    - 트랜잭션 시작
> 5. 사용자의 입력 내용을 DBMS에 저장
> 6. 첨부 파일 정보를 DBMS에 저장
>    - 트랜잭션 종료
> 7. 저장된 내용 또는 기타 정보를 DBMS에서 조회
> 8. 게시물 등록에 대한 알림 메일 발송
>    - 트랜잭션 시작
> 9. 알림 메일 발송 이력을 DBMS에 저장
>    - 트랜잭션 종료 (COMMIT)
>    - 데이터베이스 커넥션 반납
> 10. 처리 완료

- 프로그램의 코드가 데이터베이스 커넥션을 가지고 있는 범위와 트랜잭션이 활성화돼 있는 프로그램의 범위를 최소화 하자!

# **2. MySQL 엔진의 잠금**

- MySQL에서 사용되는 잠금은 다음과 같이 나뉘어진다
  - 스토리지 엔진 레벨
    - 스토리지 엔진 간 상호 영향을 미치지는 않음
  - MySQL 엔진 레벨
    - 스토리지 엔진을 제외한 나머지 부분
    - 모든 스토리지 엔진에 영향을 미침

### **1. 글로벌 락**

- ```
  FLUSH TABLES WITH READ LOCK
  ```

   명령으로 획득 가능

  - 실행과 동시에 모든 테이블을 닫고 잠금을 건다

- MySQL에서 제공하는 잠금 가운데 가장 범위가 큼

  - MySQL 서버 전체에 영향을 미치며, 작업 대상 테이블이나 데이터베이스가 다르더라도 동일하게 영향을 미침

- MySQL 서버가 업그레이드 되면서 InnoDB 스토리지 엔진의 사용이 일반화 됨 -> 트랜잭션을 지원하기 때문에 일관된 데이터 상태를 위해 모든 데이터 변경 작업을 멈출 필요는 없음 -> 조금 더 가벼운 글로벌 락의 필요성이 생김 -> **백업 락**이 도입됨

### **백업 락**

- 특정 세션에서 백업 락을 획득하면 모든 세션에서 다음과 같은 테이블의 스키마나 사용자의 인증 관련 정보를 변경할 수 없게 됨
  - 데이터베이스 및 테이블 등 모든 객체 생성 및 변경, 삭제
  - REPAIR TABLE과 OPTIMIZE TABLE 명령
  - 사용자 관리 및 비밀번호 변경
- 백업 락은 일반적인 테이블의 데이터 변경은 허용됨

### **2. 테이블 락**

- 개별 테이블 단위로 설정되는 잠금이며 명시적 또는 묵시적으로 특정 테이블의 락을 획득할 수 있음

- 명시적 테이블 락 :

  ```
  LOCK TABLES table_name [READ|WRITE]
  ```

  - `UNLOCK TABLES` 명령으로 잠금을 해제할 수 있음

- 묵시적 테이블 락 : MyISAM이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생

  - MySQL 서버가 데이터가 변경되는 테이블에 잠금을 설정 -> 데이터 변경 -> 즉시 잠금을 해제
  - 쿼리가 실행되는 동안 자동으로 획득됐다가 쿼리가 완료된 후 자동 해제 됨
  - InnoDB 테이블 : 단순 데이터 변경 쿼리로 인해 묵시적인 테이블 락이 설정되지는 않음
    - InnoDB 테이블에도 테이블 락이 설정되지만 대부분의 데이터 변경(DML) 쿼리에서는 무시되고, 스키마를 변경하는 쿼리(DDL)의 경우에만 영향을 미침

### **3. 네임드 락**

- `GET_LOCK()` 함수를 이용해 임의의 문자열에 대해 잠금을 설정할 수 있음
- 단순히 사용자가 지정한 문자열(String)에 대해 획득하고 해제하는 잠금
- 자주 사용되지는 않는다..

### **4. 메타데이터 락**

- 데이터베이스 객체의 이름이나 구조를 변경하는 경우에 획득하는 잠금

## **3. InnoDB 스토리지 엔진 잠금**

### 1. InnoDB 스토리지 엔진의 잠금

- 레코드 락
  - 레코드 자체만을 잠그는 것
  - 인덱스의 레코드를 잠금 -> 인덱스가 없는 테이블이더라도 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정
- 갭 락
  - 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것을 의미
  - 레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어하는 것

- 넥스트 키 락
  - 레코드 락 + 갭 락을 합쳐 놓은 형태의 잠금

- 자동 증가 락
  - AUTO_INCREMENT 칼럼이 사용된 테이블에 동시에 여러 레코드가 INSERT 되는 경우, 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가하는 일련번호 값을 가져야함
  - 이를 위해 AUTO_INCREMENT(자동 증가)락 이라고 하는 테이블 수준의 잠금을 사용
  - `INSERT`, `REPLACE` 에서만 필요
  - 트랜잭션과 관계없이 AUTO_INCREMENT 값을 가져오는 순간만 락이 걸렸다고 즉시 해제됨
  - 두개의 INSERT 쿼리가 동시에 실행되는 경우 하나의 쿼리가 AUTO_INCREMENT 락을 걸면 나머지 쿼리는 AUTO_INCREMENT 락을 기다려야 함
  - 명시적으로 획득/해제하는 방법은 없음
  - 문제된는 경우 별로 X

### 2. 인덱스와 잠금

- InnoDB의 잠금은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리됨
- 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 락을 걸어야 함

> UPDATE문 e.g
>
> - employees 테이블에는 first_name 칼럼만 멤버로 담긴 ix_firstname 인덱스가 존재
> - employees 테이블에서 first_name = 'Georgi'인 사원은 전체 253명, first_name = 'Georgi', last_name = 'Klassen'인 사원은 딱 1명만 존재
> - employees 테이블에서 first_name = 'Georgi', last_name = 'Klassen' 인 사원의 입사 일자를 오늘로 변경하는 쿼리 실행
>   - `UPDATE employees SET hire_date = NOW() WHERE first_name = 'Georgi' AND last_name = 'Klassen';`
>   - 한 건의 레코드 업데이트
>   - 인덱스를 이용할 수 있는 조건
>     - `first_name = 'Georgi'`
>     - `last_name` 에는 인덱스가 없다..
>   - 레코드 253건이 모두 잠김.............
> - 인덱스가 하나도 없었다면? -> 풀스캔..................... 인덱스 설계 중요하다

- UPDATE 문장을 위해 적절한 인덱스가 준비돼 있지 않다면 각 클라이언트 간의 동시성이 상당히 떨어짐
- 한 세션에서 UPDATE 작업을 하는 중에는 다른 클라이언트는 그 테이블을 업데이트 하지 못하고 기다려야 하는 상황 발생



### 3. 레코드 수준의 잠금 및 해제
