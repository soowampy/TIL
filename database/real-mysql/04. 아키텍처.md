# 4장 아키텍처

my sql 서버 - MYSQL 엔진(사람의 머리), 스토리지 엔진(손발 역할)으로 구분

# 1. MysQL 엔진 아키텍처

### 1. MySQL의 전체 구조

- mysql 엔진 : 요청된 SQL 문장을 분석하거나 최적화 하는 등 DBMS의 두뇌에 해당하는 처리를 수행
    - 커넥션 핸들러 - 클라이언트로부터의 접속 및 쿼리 요청을 처리
    - SQL 파서 및 전처리기
    - 옵티마이저 : 쿼리의 최적화된 실행
- 스토리지 엔진 : **실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분**. 여러개를 동시에 사용할 수 있음
    - InnoDB, MyISAM, Memory
- 핸들러 API
    - MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때는 각 스토리지 엔진에 쓰기 또는 읽기를 요청하는데, 이러한 요청을 핸들러 요청이라 함

### 2. MYSQL 스레딩 구조

- MySQL 서버는 프로세스 기반이 아니라 **스레드 기반**으로 작동, 포그라운드 스레드와 백그라운드 스레드로 구분
1. 포그라운드 스레드(클라이언트 스레드)
    - 최소 MySQL 서버에 접속된 클라이언트의 수만큼 존재하며 **주로 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리**
    - 클라이언트 사용자가 작업을 마치고 커넥션을 종료하면 해당 커넥션을 종료하면 해당 커넥션을 담당하던 스레드는 다시 스레드 캐시로 되돌아감
    - 이미 스레드 캐시에 일정 개수 이상의 대기중인 스레드가 있으면? **스레드 캐시에 넣지 않고 스레드를 종료시켜 일정 개수의 스레드만 스레드 캐시에 존재하게 함**
        - 스레드 캐시에 유지할 수 있는 최대 스레드 개수 : thread_cache_size 시스템 변수로 설정
    - 데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져오며 버퍼나 캐시에 없는 경우 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업을 처리
        - MyISAM 테이블 - 디스크 쓰기 작업까지 포글운드 스레드가 처리
        - InnoDB 테이블 - 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리, 나머지 버퍼로부터 디스크까지 기록하는 작업을 백그라운드 스레드가 처리
2. 백그라운드 스레드
    - InnoDB에서 백그라운드로 처리되는 부분(MyISAM는 해당 사항 없음)
        - 인서트 버퍼를 병헙하는 스레드
        - 로그를 디스크로 기록하는 스레드
        - InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
        - 데이터를 버퍼로 읽어 오는 스레드
        - 잠금이나 데드락을 모니터링하는 스레드
    - 데이터를 읽는 작업은 주로 클라이언트 스레드에서 처리되기 때문에 읽기 스레드는 많이 설정할 필요가 없지만 쓰기 스레드는 아주 많은 작업을 백그라운드로 처리하기 때문에 일반적인 내장 디스크를 사용할 때는 2~4정도~~~ 충분히 설정하자
    - 읽기작업은 지연될 수 없음! → 대부분 쓰기 작업을 버퍼링해서 일괄 처리하는 기능이 설계되어있음
        - InnoDB에서는 INSERT, UPDATE, DELETE 쿼리로 데이터가 변경되는 경우 데이터가 디스크의 데이터 파일로 완전히 저장될 때까지 기다리지 않아도 됨

### 3. 메모리 할당 및 사용구조

- 글로벌 메모리 영역 / 로컬 메모리 영역으로 구분
- 글로벌 메모리 영역의 모든 메모리 공간은 MySQL 서버가 시작되면서 운영체제로 할당. MySQl의 시스템 변수로 설정해 둔 만큼 운영체제로부터 메모리를 할당받음
1. 글로벌 메모리 영역
    - 일반적으로 클라이언트 스레드의 수와 무관하게 **하나의 메모리 공간만 할당됨**
    - 필요에 따라 2개 이상의 메모리 공간을 할당받을 수도 있지만 클라이언트의 스레드 수와는 무관, **생성된 글로벌 영역이 N개라 하더라도 모든 스레드에 의해 공유됨**
    - 대표적  글로벌 메모리 영역
        - 테이블 캐시
        - InnoDB 버퍼 풀
        - InnoDB 어댑티브 해시 인덱스
        - InnoDB 리두 로그 버퍼
2. 로컬 메모리 영역 (세션 메모리 영역)
    - MySQL 서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역
    - 커넥션 버퍼, 정렬(sort) 버퍼 등이 있음
    - 로컬 메모리는 각 클라이언트 스레드별로 독립적으로 할당되며 절대 공유되어 사용되지 않는다는 특징이 있음
    - 쿼리의 용도별로 필요할 때만 공간이 할당되고 필요하지 않은 경우에는 MySQL이 메모리 공간을 할당조차도 하지 않을 수 있음
    - 대표적 로컬 메모리 영역
        - 정렬 버퍼
        - 조인 버퍼
        - 바이너리 로그 캐시
        - 네트워크 버퍼

### 4. 플러그인 스토리지 엔진 모델

- 핸들러 : 어떤 기능을 호출하기 위해 사용하는 운전대와 같은 역할을 하는 객체
    - MySQL 엔진이 각 스토리지 엔진에게 데이터를 읽어오거나 저장하도록 명령하려면 반드시 핸들러를 통해야 함
- 하나의 쿼리 작업은 여러 하위 작업으로 나뉘는데, 각 하위 작업이 MySQL 엔진 영역에서 처리되는지 스토리지 엔진 영역에서 처리되는지 구분할 줄 알아야 함
- MySQL 서버에서 지원되는 스토리지 엔진
    - SHOW PLUGINS
- MySQl 서버에서는 스토리지 엔진뿐만 아니라 다양한 기능을 플러그인 형태로 지원
    - 인증, 전문 검색 파서, 쿼리 재작성과 같은 프러그인들이 있당…………..MySQL 매뉴얼을 참조
        - https://dev.mysql.com/doc/refman/8.0/en/server-plugins.html

### 5. 컴포넌트

- MySQL 8.0부터는 기존의 플러그인 아키텍처를 대체하기 위해 컴포넌트 아키텍처가 지원됨

### 6. 쿼리 실행 구조

- MySQL 엔진의 처리 영역
    1. SQL 파서
    2. SQL 옵티마이저
    3. SQL 실행기
- 스토리지 엔진의 처리 영역
    - 데이터 읽기/쓰기

1. 쿼리 파서
    - 사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만들어 내는 작업
    - 쿼리 문장의 기본 문법 오류는 이 과정에서 발견되고 사용자에게 오류 메시지를 전달하게 됨
2. 전처리기
    - 파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인
    - 각 토큰을 테이블 이름이나 칼럼 이름, 또는 내장 함수와 같은 개체를 매핑해 해당 객체의 존재 여부와 객체의 접근 권한 등을 확인하는 과정을 수행
    - 실제 존재하지 않거나 권한상 사용할 수 없는 개체의 토큰은 이 단계에서 걸러짐
3. 옵티마이저
    - 사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지를 결정하는 역할을 담당
    - DBMS의 두뇌에 해당
4. 실행 엔진
    - DBMS의 손과 발
    - 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행
5. 핸들러 (스토리지 엔진)
    - MySQL 서버의 가장 밑단에서 MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어 오는 역할을 담당

### 7. 복제

### 8. 쿼리 캐시

- MySQL 서버의 기능에서 완전히 제거됨

### 9. 스레드 풀

- 내부적으로 사용자의 요청을 처리하는 스레드 개수를 줄여서 동시 처리되는 요청이 많다하더라도 MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있게 해서 서버의 자원 소모를 줄이는 것이 목적

### 10. 트랜잭션 지원 메타데이터

- MySQL 8.0부터 시스템 테이블을 모두 InnoDB 스토리지 엔진을 사용하도록 개선했으며, 시스템 테이블과 데이터 딕셔너리 정보를 모두 모아서 mysql DB에 저장하고 있음
- mysql DB는 통째로 mysql.ibd라는 이름의 테이블 스페이스에 저장됨

## 2. InnoDB 스토리지 엔진 아키텍처

### 1. 프라이머리 키에 의한 클러스터링

- InnoDB의 모든 테이블은 기본적으로 **프라이머리 키를 기준으로 클러스터링되어 저장**됨
    - 프라이머리 키 값의 순서대로 디스크에 저장됨
    - 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용함
    - 프라이머리 키가 클러스터링 인덱스이기 때문에 프라이머리 키를 이용한 레인지 스캔은 상당히 빨리 처리될 수 있음
- 결과적으로 **쿼리의 실행 계획에서 프라이머리 키는 기본적으로 다른 보조 인덱스에 비해 비중이 높게 설정 됨**

### 2. 외래 키 지원

- InnoDB에서 외래 키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요
- 외래 키는 데이터베이스 서버 운영의 불편함 때문에 서비스용 데이터베이스에서는 생성하지 않는 경우도 있음…….그래도 개발환경의 DB에서는 좋은 가이드 역할이 된당.
- 변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하므로 이 여러 테이블로 전파되고, 그로 인해 데드락이 발생할 때가 많으므로 개발할 때도 외래 키의 존재에 주의하는 것이 좋음

### 3. MVCC (Multi Version Concurrency Control)

- 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능이며, 잠금을 사용하지 않는 읽관된 읽기를 제공
- 언두로그(Undo log)를 이용해 이 기능을 구현

# **`언두 영역이란?`**

언두 영역은 UPDATE 문장이나 DELETE 문장으로 데이터를 변경했을 때 변경되기 전의 데이터(이전 데이터)를 보관하는 곳입니다.

```sql
UPDATE membereSET name='홍길동'WHERE member_id = '1';
```

위 문장의 실행되면 트랜잭션을 커밋하지 않아도 실제 데이터 파일 내용은 `홍길동`으로 변경됩니다. 그리고 변경되기 전의 값이 `Gyunny` 였다면, 언**두 영역에는 `Gyunny`라는 값이 백업되는 것**입니다. 이 상태에서 사용자가 커밋하게 되면 현재 상태가 그대로 유지되고, 롤백하게 되면 언두 영역의 백업된 데이터를 다시 데이터 파일로 복구합니다.

언두의 데이터는 크게 두 가지 용도로 사용됩니다.

- 트랜잭션의 롤백 대비용
- 트랜잭션의 격리 수준을 유지하면서 높은 동시성을 제공

- e.g update문 실행
    - 아직 commit이나 rollback이 되지 않은 상태에서 다른 사용자가 작업 중인 레코드를 조회하면 어디에 있는 데이터를 조회할까? → 시스템 변수(trnasaction_isolation)에 설정된 격리 수준(Isolation level)에 따라 다름
    - 격리 수준이 `READ_UNCOMMITTED` 인 경우에는 InnoDB 버퍼 풀이나 데이터 파일로부터 변경되지 않은 데이터를 읽어서 반환 → 커밋 되든 말든 변경된 상태의 데이터 변환
    - 그 이상의 격리 수준(`REPEATABLE_READ`, `SEARIALIZABLE` ) 인 경우에는 아직 커밋되지 않았기 때문에 InnoDB 버퍼 풀이나 데이터 파일에 있는 내용 대신 변경되기 이전의 내용을 보관하고 있는 언**두 영역의 데이터를 반환** →MVCC
- 트랜잭션이 길어지면 언두에서 관리하는 예전 데이터가 삭제되지 못하고 오랫동안 관리돼야 하며, 자연히 언두 영역이 저장되는 시스템 테이블 스페이스의 공간이 많이 늘어나는 상황 발생

### 4. 잠금 없는 일관된 읽기 (Non-Locking Consistent Read)

- InnoDB는 MVCC를 이용해 잠금을 걸지 않고 읽기 작업을 수행
    - 잠금을 걸지 않기 때문에 InnoDB에서 읽기 작업은 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고, 읽기 작업이 가능함
- 오랜 시간 동안 활성 상태인 트랜잭션으로 인해 서버가 느려지거나 문제가 발생할 때가 가끔 있는데, 이러한 일관된 읽기를 위해 언두 로그를 삭제하지 못하고 계속 유지해야 하기 때문에 발생하는 문제
    - 트랜잭션이 시작됐다면 가능한 한 빨리 롤백이나 커밋을 통해 트랜잭션을 완료시키자

### 5. 자동 데드락 감지

- InnoDB 스토리지 엔진은 데드락 감지 스레드를 가지고 있어서 데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션들을 찾아서 그 중 하나를 강제종료한다
    - 어느 트랜잭션을 먼저 강제 종료할 것인가 → 트랜잭션의 언두 로그 양
- `innodb_table_locks` 시스템 변수를 활성화하면 InnoDB 스토리지 엔진 내부의 레코드 잠금뿐만 아니라 테이블 레벨의 잠금까지 감지할 수 있게 됨
- 동시 처리 스레드가 매우 많은 경우 데드락 감지 스레드는 더 많은 CPU를 소모할 수 있음,,,,,
    - `innodb_deadlock_detect` off

### 6. 자동화된 장애 복구

### 7. InooDB 버퍼 풀

- **디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간**
- 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 같이 함

1. 버퍼 풀의 구조
    - InnoDB 스토리지 엔진은 버퍼 풀이라는 거대한 메모리 공간을 페이지 크기의 조각으로 쪼개어 InnoDB 스토리지 엔진이 데이터를 필요로 할 때 해당 데이터 페이지를 읽어서 각 조각에 저장
    - LRU(Least Recently Used) 리스트와 플러시(Flush) 리스트, 프리(Free) 리스트라는 3개의 자료 구조를 관리
        - 프리 리스트
            - InnoDB 버퍼 풀에서 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지들의 목록
            - 사용자의 쿼리가 새롭게 디스크의 데이터 페이지를 읽어와야 하는 경우 사용
        - LRU 리스트 (LRU→New 서브 리스트 + MRU(Most Recently Used→Old 서브 리스트)
            - 디스크로부터 한 번 읽어온 페이지를 최대한 오랫동안 InnoDB 버퍼풀의 메모리에 유지해서 디스크 읽기를 최소화 하는 것
            - 처음 한 번 읽힌 데이터 페이지가 이후 자주 사용된다면 그 데이터 페이지는 MRU 영역에서 계속 살아남게 되고 반대의 경우에는 밀려서 InnoDB 버퍼 풀에서 제거
        - 플러시 리스트
            - 디스크로 동기화되지 않은 데이터를 가진 데이터 페이지(더티 페이지)의 변경 시점 기준의 페이지 목록을 관리
            - 디스크에서 읽은 상태 그대로 전혀 변경이 없다면 플러시 리슽트에 관리되지 않지만, 한 번 데이터 변경이 가해진 데이터 페이지는 플러시 리스트에 관리되고 특정 시점이 되면 디스크로 기록돼야 함
            - 데이터가 변경되면 InnoDB는 변경 내용을 리두 로그에 기록하고 버퍼 풀의 데이터 페이지에도 변경 내용으 ㄹ반영함
            
        1. 버퍼 풀과 리두 로그
            - 버퍼 풀
                - 서버의 메모리가 허용하는 만큼 크게 설정하면 할수록 쿼리의 성능이 빨라짐
                - InooDB 버퍼 풀은 데이터 캐시와 쓰기 버퍼링이라는 두 가지 용도가 있다
                    - 메모리 공간만 늘리는 것은 데이터 캐시 기능만 향상시키는 것
                - 디스크에서 읽은 상태로 전혀 변경되지 않은 클린 페이지와 함께 C,D,U 명령으로 변경된 데이터를 가진 더티 페이지도 갖고있음…..더티페이지는 버퍼 풀에 무한정 머무를 수 있는 건 아니다.
                - 데이터 변경이 계속 발생하면 리두 로그 파일에 기록 됐던 로그 엔트리는 어느 순간 다시 새로운 로그 엔트리로 덮어 쓰임
                    - InnoDB 스토리지 엔진은 전체 리두 로그 파일에서 재사용 가능한 공간과 당장 재사용 불가능한 공간을 구분해서 관리해야하는데, 재사용 불가능한 공간을 활성 리두 로그라고 함
                - 리두 로그 파일 공간은 계속 순환되어 재사용되지만 매번 기록될 때마다 로그 포지션은 계속 증가된 값을 갖게 되는데 이를 LSN(Log Sequence Number)라고 함
                
        2. 버퍼 풀 플러시 (Buffer Pool Flush)
            - 버퍼 풀에서 아직 디스크로 기록되지 않은 더티 페이지들을 성능상의 악영향 없이 디스크에 동기화하기 위해 2개의 플러시 기능을 백그라운드로 실행
            1. 플러시 리스트 플러시
                - InnoDB 스토리지 엔진은 리두 로그 공간의 재활용을 위해 주기적으로 오래된 리두 로그 엔트리가 사용하는 공간을 비워야 함 → InnoDB 버퍼풀의 더티 페이지가 먼저 리스크로 동기화 돼야 함→ InnoDB 스토리지 엔진은 주기적으로 **플러시 리스트 플러시 함수를 호출해서 플러시 리스트에서 오래전에 변경된 데이터 페이지 순서대로 디스크에 동기화하는 작업을 수행**
                - InnoDB 버퍼 풀에 더티 페이지가 많으면 많을수록 디스크 쓰기 폭발 현상이 발생할 가능성이 높아짐
                    - `innodb_max_dirty_pages_pct-lwm` 라는 시스템 설정 변수를 이용해 일정 수준 이상의 더티 페이지가 발생하면 조금씩 더티 페이지를 디스크로 기록하게 하고 있음
            2. LRU 리스트 플러시
                - InnoDB 스토리지 엔진은 LRU 리스트에서 사용 빈도가 낮은 데이터 페이지들을 제거해서 새로운 페이지들을 읽어올 공간을 만들어야 하는데, 이르 ㄹ위해 LRU 리스트 플러시 함수가 사용됨
                - 더티 페이지는 디스크에 ㄷ ㅗㅇ기화, 클린 페이지는 프리 리스트로 페이지를 옮김
        3. 버퍼 풀 상태 백업 및 복구
            - 디스크의 데이터가 버퍼 풀에 적재돼 있는 상태 - 워밍 업(Warming Up)
                - 버퍼 풀이 잘 워밍업 된 상태에서는 그렇지 않은 경우보다 몇십 배의 쿼리 처리 속도를 보이는 것이 일반적
        
         6. 버퍼 풀의 적재 내용 확인
        
        - innodb_cached_indexes → 테이블의 인덱스별로 데이터 페이지가 얼마나 InnoDB 버퍼 풀에 적재돼 있는지 확인할 수 있음

### 8. Double Write Buffer

- InnoDB 스토리지 엔진의 리두 로그는 리두 로그 공간의 낭비를 막기 위해 페이지의 변경된 내용만 기록
- 이렇게 페이지가 일부만 기록되는 현상을 파셜 페이지 또는 톤페이지라고 함→하드웨어 오작동/시스템 비정상 종료 등으로 발생할 수 있음
- 이와같은 문제를 막기 위해 Double-Write 기법을 이용

### 9. 언두 로그

- InnoDB 스토리지 엔진은 트랜잭션과 격리 수준을 보장하기 위해 DML로 변경되기 이전 버전의 데이터를 별도로 백업 → 언두 로그
- 트랜잭션 보장 : 트랜잭션이 롤백되면 트랜잭션 도중 변경된 데이터를 변경 전 데이터로 복구해야 하는데, 이 때 언두 로그에 백업해둔 이전 버전의 데이터를 이용해 복구함
- 격리 수준 보장 : 특정 커넥션에서 데이터를 변경하는 도중에 다른 커넥션에서 데이터를 조회하면 트랜잭션 격리 수준에 맞게 변경 중인 레코드를 읽지 않고 언두 로그에 백업해둔 데이터를 읽어서 반환하기도 함
1. 언두 로그 레코드 모니터링
    - 대용량의 데이터를 처리하는 트랜잭션뿐만 아니라 트랜잭션이 오랜 시간 동안 실행될 때도 언두 로그의 양은 급격히 증가할 수 있음
    - 트랜잭션이 완료됐다고 해서 해당 트랜잭션이 생성한 언두 로그를 즉시 삭제할 수 있는 것은 아님
    - 서버별로 안정적인 시점의 언두 로그 레코드 건수를 확인해 이를 기준으로 언두 로그의 급증 여부를 모니터링하자
2. 언두 테이블스페이스 관리
    - 언두 테이블스페이스 : 언두 로그가 저장되는 공간
    - 하나의 언두 테이블스페이스는 1개 이상 128개 이하의 롤백 세그컨트를 가지며, 롤백 세그먼트는 1개 이상의 언두슬롯을 가짐

### 10. 체인지 버퍼

- RDBMS에서 레코드가 INSERT 되거나 UPDATE 될 때는 데이터 파일을 변경하는 작업뿐 아니라 해당 테이블에 포함된 인덱스를 업데이트하는 작업도 필요
- 인덱스를 업데이트 하는 작업은 랜덤하게 디스크를 읽는 작업이 필요하므로 테이블에 인덱스가 많다면 이 작업은 상당히 많은 자원을 소모하게 된다………………
- 변경해야 하는 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행하지만 그렇지 않고 디스크로부터 읽어와서 업데이트해야 한다면 이를 즉시 실행하지 않고 임시 공간에 저장해두고 바로 사용자에게 결과를 반환하는 형태로 성능을 향상시키게 됨! → 체인지 버퍼
- 유니크 인덱스는 체인지 버퍼를 사용할 수 없음

### 11. 리두 로그 및 로그 버퍼

- 리두 로그 : 하드웨어나 소프트웨어 등 여러 가지 문제점으로 인해 MySQL 서버가 비정상적으로 종료도ㅒㅆ을 때 데이터 파일에 기록되지 못한 데이터를 잃지 않게 해주는 안전장치
- DB서버는 데이터 번경 내용을 로그로 먼저 기록 → 데이터 파일 쓰기는 디스크의 랜덤 액세스가 필요 → 변경된 데이터를 데이터 파일에 기록하려면 상대적으로 큰 비용이 필요 → 이러한 성능 저하를 막기 위해 리두 로그가 있음!!
- 비정상 종료가 발생하면 리두 로그의 내용을 이용해 데이터 파일을 다시 서버가 종료되기 직전이ㅡ 상태로 복구

### 12. 어댑티브 해시 인덱스

- 사용자가 수동으로 생성하는 인덱스가 아니라 InnoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스
- 어댑티브 해시 인덱스는 B-Tree 검색 시간을 줄여주기 위해 도입된 기능
- 자주 읽히는 데이터 페이지의 키 값을 이용해 해시 인덱스를 만들고, 필요할 때마다 어댑티브 해시 인덱스를 검색해서 레코드가 저장된 데이터 페이지를 즉시 찾아갈 수 있음
- 어댑티브 해시 인덱스가 성능 향상에 크게 도움이 되지 앟는 ㄴ경우
    - 디스크 읽기가 많은 경우
    - 특정 패턴의 쿼리가 많은 경우 (조인이나 LIKE 패턴 검색)
    - 매우 큰 데이터를 가진 테이블의 레코드를 폭넓게 읽는 경우
- 도움되는 경우
    - 디스크의 데이터가 InnoDB 버퍼 풀 크기와 비슷한 경우(디스크 읽기가 많지 않은 경우)
    - 동등 조건 검색(동등 비교와 IN 연산자)이 많은 경우
    - 쿼리가 데이터 중에서 일부 데이터에만 집중되는 경우
